#include <codegen/AssemblerPassEmit.h>

#include <chrono>
#include <ctime>
#include <iomanip>
#include <sstream>



namespace billiec::codegen {

void AssemblerPassEmit::process() {
    for(auto& curr: instructions) {
        process_node_(curr);
    }
}

void AssemblerPassEmit::process_node_(AssemblerNode::PtrType& curr_node) {
    if(auto node = dynamic_cast<ProgramAssemblerNode*>(curr_node.get())) {
        visit_node_(*node);
    } else if (auto node = dynamic_cast<CompoundAssemblerNode*>(curr_node.get())) {
        visit_node_(*node);
    } else if (auto node = dynamic_cast<FunctionAssemblerNode*>(curr_node.get())) {
        visit_node_(*node);
    } else if (auto node = dynamic_cast<MovInstructionNode*>(curr_node.get())) {
        visit_node_(*node);
    } else if (auto node = dynamic_cast<ReturnInstructionNode*>(curr_node.get())) {
        visit_node_(*node);
    } else if (auto node = dynamic_cast<LiteralInstructionNode*>(curr_node.get())) {
        visit_node_(*node);
    } else if (auto node = dynamic_cast<RegisterInstructionNode*>(curr_node.get())) {
        visit_node_(*node);
    } else if (auto node = dynamic_cast<UnaryInstructionNode*>(curr_node.get())) {
        visit_node_(*node);
    } else if (auto node = dynamic_cast<AllocateStackInstructionNode*>(curr_node.get())) {
        visit_node_(*node);
    } else if (auto node = dynamic_cast<DeAllocateStackInstructionNode*>(curr_node.get())) {
        visit_node_(*node);
    } else if (auto node = dynamic_cast<PseudoRegister*>(curr_node.get())) {
        visit_node_(*node);
    } else if (auto node = dynamic_cast<Stack*>(curr_node.get())) {
        visit_node_(*node);
    } else {
        // TODO: Error, hey what happen.
    }
}

void AssemblerPassEmit::visit_node_(CompoundAssemblerNode& node) {
    for(auto& curr_node: node.instructions) {
        process_node_(curr_node);
    }
}

void AssemblerPassEmit::visit_node_(ProgramAssemblerNode& node) {
    ostream << "; Generated by billie-c\n";
    auto now = std::chrono::system_clock::now();
    auto in_time_t = std::chrono::system_clock::to_time_t(now);

    std::stringstream ss;
    ss << std::put_time(std::localtime(&in_time_t), "%Y-%m-%d %X");
    ostream << "; " << ss.str() << "\n";
    
    process_node_(node.function_definition);
}

void AssemblerPassEmit::visit_node_(FunctionAssemblerNode& node) {
    ostream << ".global _" << node.name.lexeme << "\n";
    ostream << "_" << node.name.lexeme << ": \n";
    for(auto& curr: node.instructions) {
        process_node_(curr);
    }
}

void AssemblerPassEmit::visit_node_(MovInstructionNode& node) {
    ostream << "mov ";
    process_node_(node.dst);
    ostream << ", ";
    process_node_(node.src);
    ostream << "\n";
}

void AssemblerPassEmit::visit_node_(ReturnInstructionNode& node) {
    ostream << "ret\n";
}

void AssemblerPassEmit::visit_node_(LiteralInstructionNode& node) {
    ostream << std::get<int>(node.value);
}

void AssemblerPassEmit::visit_node_(RegisterInstructionNode& node) {
    ostream << "w0";
}

void AssemblerPassEmit::visit_node_(UnaryInstructionNode& node) {
    
}

void AssemblerPassEmit::visit_node_(AllocateStackInstructionNode& node) {
    ostream << "sub sp, sp, #" << node.size << "\n";
}

void AssemblerPassEmit::visit_node_(DeAllocateStackInstructionNode& node) {
    ostream << "add sp, sp, #" << node.size << "\n";
}

void AssemblerPassEmit::visit_node_(PseudoRegister& node) {
    ostream << node.identifier;
}

void AssemblerPassEmit::visit_node_(Stack& node) {
    ostream << "stack+" << node.offset;
}

} // namespace billiec::codegen
