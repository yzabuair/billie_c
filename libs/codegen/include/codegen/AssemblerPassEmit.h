// Copyright 2025 Yasser Zabuair.  See LICENSE for details.
#pragma once

#include <codegen/AssemblerAst.h>

#include <iostream>
#include <vector>

namespace billiec::codegen {
struct AssemblerPassEmit {
    std::vector<AssemblerNode::PtrType>& instructions;
    std::ostream& ostream;
    
    AssemblerPassEmit(std::vector<AssemblerNode::PtrType>& instructions,
                      std::ostream& ostream):
        instructions{instructions},
        ostream{ostream} {
    }
    ~AssemblerPassEmit() = default;
    
    void process() {
        for(const auto& curr: instructions) {
            
        }
    }
    
    void process_node(AssemblerNode::PtrType& curr_node) {
        if(ProgramAssemblerNode* node = dynamic_cast<ProgramAssemblerNode*>(curr_node.get())) {
            visit_node(*node);
        }
    }
    
    void visit_node(CompoundAssemblerNode& node) {
        for(auto& curr_node: node.instructions) {
            
        }
    }
    
    void visit_node(ProgramAssemblerNode& node) {
        ostream << "; Generated by billie-c\n";
    }
    
    void visit_node(FunctionAssemblerNode& node) {
        ostream << ".global _" << node.name << "\n";
        ostream << "_" << node.name << ": \n";
        for(auto& curr: node.instructions) {
            //curr->assembler_pass(*this);
        }
    }
    
    void visit_node(MovInstructionNode& node) {
        ostream << "MOV ";
        //node.dst->assembler_pass(*this);
        ostream << ", ";
        //node.src->assembler_pass(*this);
        ostream << "\n";
    }
    
    void visit_node(ReturnInstructionNode& node) {
        
    }
    
    void visit_node(LiteralInstructionNode& node) {
        
    }
    
    void visit_node(RegisterInstructionNode& node) {
        
    }
    
    void visit_node(UnaryInstructionNode& node) {
        
    }
    
    void visit_node(AllocateStack& node) {
        
    }
    
    void visit_node(PseudoRegister& node) {
        
    }
};

} // namespace billiec::codegen
