// Copyright 2025 Yasser Zabuair.
#pragma once

#include <scanner/Token.h>

#include <iostream>
#include <memory>
#include <vector>

namespace billiec::codegen {

// Forwards
struct ProgramAssemblerNode;
struct FunctionAssemblerNode;
struct ReturnInstructionNode;
struct LiteralInstructionNode;

struct AssemblerNode {
    AssemblerNode() {
    }
    
    virtual ~AssemblerNode(){
    }
    
    virtual void generate(std::ostream& ostream) = 0;
};

// ---

struct ProgramAssemblerNode: public AssemblerNode {
    using PtrType = std::unique_ptr<ProgramAssemblerNode>;
    std::unique_ptr<AssemblerNode> function_definition;
    
    ProgramAssemblerNode(std::unique_ptr<AssemblerNode> function_definition):
        function_definition{std::move(function_definition)} {
    }
    
    static PtrType create(std::unique_ptr<AssemblerNode> function_definition) {
        return std::make_unique<ProgramAssemblerNode>(std::move(function_definition));
    }
    
    void generate(std::ostream& ostream) override {
        ostream << "; Generated by the billie-c compiler.\n";
        function_definition->generate(ostream);
    }
};

// ---

struct FunctionAssemblerNode: public AssemblerNode {
    using PtrType = std::unique_ptr<FunctionAssemblerNode>;
    scanner::Token name;
    std::vector<std::unique_ptr<AssemblerNode>> instructions;
    
    FunctionAssemblerNode(const scanner::Token& name,
                 std::vector<std::unique_ptr<AssemblerNode>> instructions):
        name{name},
        instructions{std::move(instructions)} {
        
    }
    
    static PtrType create(const scanner::Token name,
                   std::vector<std::unique_ptr<AssemblerNode>> instructions) {
        return std::make_unique<FunctionAssemblerNode>(name, std::move(instructions));
    }
    
    void generate(std::ostream& ostream) override {
        ostream << "\t .global \t" << "_" << name.lexeme << "\n";
        ostream << "_" << name.lexeme << ":" << "\n";
        ostream << "\t .cfi_startproc\n";
        for(const auto& curr_ins: instructions) {
            curr_ins->generate(ostream);
        }
        ostream << "\t .cfi_endproc\n";
    }
};

// --

struct MovInstructionNode: public AssemblerNode {
    using PtrType = std::unique_ptr<MovInstructionNode>;
    std::unique_ptr<AssemblerNode> src;
    std::unique_ptr<AssemblerNode> dst;
    
    MovInstructionNode(std::unique_ptr<AssemblerNode> src,
                       std::unique_ptr<AssemblerNode> dst):
        src{std::move(src)},
        dst{std::move(dst)} {
        
    }
    
    static PtrType create(std::unique_ptr<AssemblerNode> src,
                          std::unique_ptr<AssemblerNode> dst) {
        return std::make_unique<MovInstructionNode>(std::move(src), std::move(dst));
    }
    
    void generate(std::ostream& ostream) override {
        ostream << "\t mov \t";
        dst->generate(ostream);
        ostream << ", ";
        src->generate(ostream);
        ostream << "\n";
    }
};

// --

struct ReturnInstructionNode: public AssemblerNode {
    using PtrType = std::unique_ptr<ReturnInstructionNode>;
    
    ReturnInstructionNode() {
        
    }
    
    static PtrType create() {
        return std::make_unique<ReturnInstructionNode>();
    }
    
    void generate(std::ostream& ostream) override {
        ostream << "\t ret\n";
    }
};

// ---

struct LiteralInstructionNode: public AssemblerNode {
    using PtrType = std::unique_ptr<LiteralInstructionNode>;
    scanner::TokenValueType value;
    
    LiteralInstructionNode(const scanner::TokenValueType& value):
        value{value} {
        
    }
    
    static PtrType create(const scanner::TokenValueType& value) {
        return std::make_unique<LiteralInstructionNode>(value);
    }
    
    void generate(std::ostream& ostream) override {
        // We only understand int for now.
        ostream << "#" << std::get<int>(value);
    }
};

// --

struct RegisterInstructionNode: public AssemblerNode {
    using PtrType = std::unique_ptr<RegisterInstructionNode>;
    
    enum class Register {
        W0 = 0
    };
    Register which_register;
    
    RegisterInstructionNode(Register which_register):
        which_register{which_register} {
    }
    
    static PtrType create(Register which_register) {
        return std::make_unique<RegisterInstructionNode>(which_register);
    }
    
    void generate(std::ostream& ostream) override {
        ostream << "w0";
    }
};


} // namespace billiec::codegen
